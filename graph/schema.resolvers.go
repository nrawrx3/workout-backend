package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strconv"

	"github.com/nrawrx3/workout-backend/graph/model"
	backend_model "github.com/nrawrx3/workout-backend/model"
	"github.com/nrawrx3/workout-backend/util"
	"github.com/rs/zerolog/log"
	"gorm.io/gorm"
)

// CreateUser is the resolver for the create_user field.
func (r *mutationResolver) CreateUser(ctx context.Context, userName string, email string) (*string, error) {
	newUser := &backend_model.User{
		UserName: userName,
		Email:    email,
	}

	err := r.DB.Create(newUser).Error
	if err != nil {
		return nil, fmt.Errorf("%w: failed to create user with email %s", err, email)
	}

	newUserID := strconv.FormatUint(newUser.ID, 10)
	return &newUserID, nil
}

// CreateWorkout is the resolver for the create_workout field.
func (r *mutationResolver) CreateWorkout(ctx context.Context, userID string, kind model.WorkoutKind, reps int, durationSeconds int, rounds *int, order int) (*string, error) {
	kindEnum := kind.CastToModelKind()

	numRounds := 0
	if rounds != nil {
		numRounds = *rounds
	}

	uintUserID, err := util.Uint64FromStringID(userID)
	if err != nil {
		return nil, err
	}

	workout := backend_model.Workout{
		Kind:            kindEnum,
		Reps:            reps,
		DurationSeconds: durationSeconds,
		Rounds:          numRounds,
		UserID:          uintUserID,
		Order:           order,
	}

	// order -1 indicates we should insert with max order
	if order == -1 {
		var maxRelativeOrder struct {
			Count int
		}

		const query = `select coalesce(max(relative_order), -1) as count from workouts where user_id = ?`
		err := r.DB.Raw(query, []interface{}{uintUserID}).First(&maxRelativeOrder).Error
		if err != nil {
			log.Error().Str("gql_resolver", "failed to get max relative_order").Str("mutation", "create_workout").Err(err)
			return nil, err
		}
		workout.Order = maxRelativeOrder.Count + 1
	}

	err = r.DB.Create(&workout).Error
	if err != nil {
		return nil, err
	}

	workoutIDString := strconv.FormatUint(workout.ID, 10)
	return &workoutIDString, nil
}

// UpdateWorkout is the resolver for the update_workout field.
func (r *mutationResolver) UpdateWorkout(ctx context.Context, workoutID string, kind model.WorkoutKind, reps int, durationSeconds int, rounds int, order int) (*string, error) {
	id, err := util.Uint64FromStringID(workoutID)
	if err != nil {
		return nil, err
	}

	w := backend_model.Workout{
		BaseModel: backend_model.BaseModel{
			ID: id,
		},
	}

	updates := map[string]interface{}{
		"kind":             kind.CastToModelKind(),
		"reps":             reps,
		"duration_seconds": durationSeconds,
		"rounds":           rounds,
	}

	if order != -1 {
		updates["relative_order"] = order
	}

	res := r.DB.Model(&w).Where("id = ?", []interface{}{id}).Updates(updates)
	if res.Error != nil {
		log.Error().Str("gql_resolver", "failed to update workout").Str("workout_id", workoutID).Str("mutation", "update_workout").Msg("query or db error")
		return nil, fmt.Errorf("failed to update workout with id '%s': %w", workoutID, res.Error)
	}
	if res.RowsAffected == 0 {
		log.Error().Str("gql_resolver", "failed to update workout").Str("workout_id", workoutID).Str("mutation", "updated_workout").Msg("due to res.RowsAffected == 0")
		return nil, fmt.Errorf("failed to update workout with id '%s': no such id", workoutID)
	}

	log.Info().Str("gql_resolver", "updated workout").Str("workput_id", workoutID)

	return &workoutID, nil
}

// ReorderWorkouts is the resolver for the reorder_workouts field.
func (r *mutationResolver) ReorderWorkouts(ctx context.Context, workoutIDAtRow []string) ([]string, error) {
	for row, workoutID := range workoutIDAtRow {
		id, err := util.Uint64FromStringID(workoutID)
		if err != nil {
			return nil, err
		}
		workout := backend_model.Workout{
			BaseModel: backend_model.BaseModel{ID: id},
		}
		err = r.DB.WithContext(ctx).Model(&workout).UpdateColumn("relative_order", row).Error
		if err != nil {
			return nil, fmt.Errorf("failed to update relative_order column for workout with id: %d: %w", id, err)
		}
	}
	return workoutIDAtRow[:], nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userUintID, err := util.Uint64FromStringID(id)
	if err != nil {
		return nil, err
	}

	var user backend_model.User
	user.ID = userUintID
	if err := r.DB.WithContext(ctx).First(&user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &model.User{
		ID:       id,
		UserName: user.UserName,
		Email:    user.Email,
	}, nil
}

// Workouts is the resolver for the workouts field.
func (r *queryResolver) Workouts(ctx context.Context, userID string) ([]*model.Workout, error) {
	userUintID, err := util.Uint64FromStringID(userID)
	if err != nil {
		return nil, err
	}

	var workouts []backend_model.Workout
	err = r.DB.WithContext(ctx).Where("user_id = ?", userUintID).Find(&workouts).Error
	if err != nil {
		return nil, err
	}

	respWorkouts := make([]*model.Workout, 0, len(workouts))
	for _, w := range workouts {
		respWorkouts = append(respWorkouts, &model.Workout{
			ID:              strconv.FormatUint(w.ID, 10),
			Reps:            w.Reps,
			Rounds:          w.Rounds,
			DurationSeconds: w.DurationSeconds,
			UserID:          userID,
			Kind:            model.WorkoutKindFromModel(w.Kind),
			Order:           w.Order,
		})
	}

	// log.Debug().Int("duration(sec)", 3).Str("gql_resolver", "sleeping before sending response").Str("query", "workouts").Msg("simulating delay")
	// <-time.After(3 * time.Second)

	log.Debug().Str("gql_resolver", "sending workouts result").Str("query", "workouts")

	for _, w := range workouts {
		fmt.Printf("Kind: %s, Reps: %d\n", w.Kind, w.Reps)
	}
	os.Stdout.Sync()
	return respWorkouts, nil
}

// UserByEmail is the resolver for the user_by_email field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*model.User, error) {
	var user backend_model.User
	if err := r.DB.Model(backend_model.User{}).Where("email = ?", email).First(&user).Error; err != nil {
		return nil, err
	}

	return &model.User{
		ID:       strconv.FormatUint(user.ID, 10),
		UserName: user.UserName,
		Email:    user.Email,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
